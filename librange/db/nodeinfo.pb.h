// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nodeinfo.proto

#ifndef PROTOBUF_nodeinfo_2eproto__INCLUDED
#define PROTOBUF_nodeinfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace range {
namespace db {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_nodeinfo_2eproto();
void protobuf_AssignDesc_nodeinfo_2eproto();
void protobuf_ShutdownFile_nodeinfo_2eproto();

class NodeInfo;
class NodeInfo_Adjacency;
class NodeInfo_Edges;
class NodeInfo_Tags;
class NodeInfo_Tags_KeyValue;
class NodeInfo_Tags_KeyValue_Values;

// ===================================================================

class NodeInfo_Adjacency : public ::google::protobuf::Message {
 public:
  NodeInfo_Adjacency();
  virtual ~NodeInfo_Adjacency();

  NodeInfo_Adjacency(const NodeInfo_Adjacency& from);

  inline NodeInfo_Adjacency& operator=(const NodeInfo_Adjacency& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo_Adjacency& default_instance();

  void Swap(NodeInfo_Adjacency* other);

  // implements Message ----------------------------------------------

  NodeInfo_Adjacency* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo_Adjacency& from);
  void MergeFrom(const NodeInfo_Adjacency& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated uint64 versions = 2;
  inline int versions_size() const;
  inline void clear_versions();
  static const int kVersionsFieldNumber = 2;
  inline ::google::protobuf::uint64 versions(int index) const;
  inline void set_versions(int index, ::google::protobuf::uint64 value);
  inline void add_versions(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:range.db.NodeInfo.Adjacency)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > versions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_nodeinfo_2eproto();
  friend void protobuf_AssignDesc_nodeinfo_2eproto();
  friend void protobuf_ShutdownFile_nodeinfo_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo_Adjacency* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo_Edges : public ::google::protobuf::Message {
 public:
  NodeInfo_Edges();
  virtual ~NodeInfo_Edges();

  NodeInfo_Edges(const NodeInfo_Edges& from);

  inline NodeInfo_Edges& operator=(const NodeInfo_Edges& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo_Edges& default_instance();

  void Swap(NodeInfo_Edges* other);

  // implements Message ----------------------------------------------

  NodeInfo_Edges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo_Edges& from);
  void MergeFrom(const NodeInfo_Edges& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .range.db.NodeInfo.Adjacency edges = 1;
  inline int edges_size() const;
  inline void clear_edges();
  static const int kEdgesFieldNumber = 1;
  inline const ::range::db::NodeInfo_Adjacency& edges(int index) const;
  inline ::range::db::NodeInfo_Adjacency* mutable_edges(int index);
  inline ::range::db::NodeInfo_Adjacency* add_edges();
  inline const ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Adjacency >&
      edges() const;
  inline ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Adjacency >*
      mutable_edges();

  // @@protoc_insertion_point(class_scope:range.db.NodeInfo.Edges)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Adjacency > edges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_nodeinfo_2eproto();
  friend void protobuf_AssignDesc_nodeinfo_2eproto();
  friend void protobuf_ShutdownFile_nodeinfo_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo_Edges* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo_Tags_KeyValue_Values : public ::google::protobuf::Message {
 public:
  NodeInfo_Tags_KeyValue_Values();
  virtual ~NodeInfo_Tags_KeyValue_Values();

  NodeInfo_Tags_KeyValue_Values(const NodeInfo_Tags_KeyValue_Values& from);

  inline NodeInfo_Tags_KeyValue_Values& operator=(const NodeInfo_Tags_KeyValue_Values& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo_Tags_KeyValue_Values& default_instance();

  void Swap(NodeInfo_Tags_KeyValue_Values* other);

  // implements Message ----------------------------------------------

  NodeInfo_Tags_KeyValue_Values* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo_Tags_KeyValue_Values& from);
  void MergeFrom(const NodeInfo_Tags_KeyValue_Values& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // repeated uint64 versions = 2;
  inline int versions_size() const;
  inline void clear_versions();
  static const int kVersionsFieldNumber = 2;
  inline ::google::protobuf::uint64 versions(int index) const;
  inline void set_versions(int index, ::google::protobuf::uint64 value);
  inline void add_versions(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:range.db.NodeInfo.Tags.KeyValue.Values)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > versions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_nodeinfo_2eproto();
  friend void protobuf_AssignDesc_nodeinfo_2eproto();
  friend void protobuf_ShutdownFile_nodeinfo_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo_Tags_KeyValue_Values* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo_Tags_KeyValue : public ::google::protobuf::Message {
 public:
  NodeInfo_Tags_KeyValue();
  virtual ~NodeInfo_Tags_KeyValue();

  NodeInfo_Tags_KeyValue(const NodeInfo_Tags_KeyValue& from);

  inline NodeInfo_Tags_KeyValue& operator=(const NodeInfo_Tags_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo_Tags_KeyValue& default_instance();

  void Swap(NodeInfo_Tags_KeyValue* other);

  // implements Message ----------------------------------------------

  NodeInfo_Tags_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo_Tags_KeyValue& from);
  void MergeFrom(const NodeInfo_Tags_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeInfo_Tags_KeyValue_Values Values;

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required uint64 key_version = 4;
  inline bool has_key_version() const;
  inline void clear_key_version();
  static const int kKeyVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 key_version() const;
  inline void set_key_version(::google::protobuf::uint64 value);

  // repeated .range.db.NodeInfo.Tags.KeyValue.Values values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::range::db::NodeInfo_Tags_KeyValue_Values& values(int index) const;
  inline ::range::db::NodeInfo_Tags_KeyValue_Values* mutable_values(int index);
  inline ::range::db::NodeInfo_Tags_KeyValue_Values* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue_Values >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue_Values >*
      mutable_values();

  // repeated uint64 versions = 3;
  inline int versions_size() const;
  inline void clear_versions();
  static const int kVersionsFieldNumber = 3;
  inline ::google::protobuf::uint64 versions(int index) const;
  inline void set_versions(int index, ::google::protobuf::uint64 value);
  inline void add_versions(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:range.db.NodeInfo.Tags.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_key_version();
  inline void clear_has_key_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::uint64 key_version_;
  ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue_Values > values_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > versions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_nodeinfo_2eproto();
  friend void protobuf_AssignDesc_nodeinfo_2eproto();
  friend void protobuf_ShutdownFile_nodeinfo_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo_Tags_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo_Tags : public ::google::protobuf::Message {
 public:
  NodeInfo_Tags();
  virtual ~NodeInfo_Tags();

  NodeInfo_Tags(const NodeInfo_Tags& from);

  inline NodeInfo_Tags& operator=(const NodeInfo_Tags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo_Tags& default_instance();

  void Swap(NodeInfo_Tags* other);

  // implements Message ----------------------------------------------

  NodeInfo_Tags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo_Tags& from);
  void MergeFrom(const NodeInfo_Tags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeInfo_Tags_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // repeated .range.db.NodeInfo.Tags.KeyValue keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::range::db::NodeInfo_Tags_KeyValue& keys(int index) const;
  inline ::range::db::NodeInfo_Tags_KeyValue* mutable_keys(int index);
  inline ::range::db::NodeInfo_Tags_KeyValue* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue >*
      mutable_keys();

  // @@protoc_insertion_point(class_scope:range.db.NodeInfo.Tags)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue > keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_nodeinfo_2eproto();
  friend void protobuf_AssignDesc_nodeinfo_2eproto();
  friend void protobuf_ShutdownFile_nodeinfo_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo_Tags* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  void Swap(NodeInfo* other);

  // implements Message ----------------------------------------------

  NodeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeInfo_Adjacency Adjacency;
  typedef NodeInfo_Edges Edges;
  typedef NodeInfo_Tags Tags;

  // accessors -------------------------------------------------------

  // required uint64 list_version = 1;
  inline bool has_list_version() const;
  inline void clear_list_version();
  static const int kListVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 list_version() const;
  inline void set_list_version(::google::protobuf::uint64 value);

  // required uint32 crc32 = 2;
  inline bool has_crc32() const;
  inline void clear_crc32();
  static const int kCrc32FieldNumber = 2;
  inline ::google::protobuf::uint32 crc32() const;
  inline void set_crc32(::google::protobuf::uint32 value);

  // required uint32 node_type = 3;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 node_type() const;
  inline void set_node_type(::google::protobuf::uint32 value);

  // required .range.db.NodeInfo.Edges forward = 4;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 4;
  inline const ::range::db::NodeInfo_Edges& forward() const;
  inline ::range::db::NodeInfo_Edges* mutable_forward();
  inline ::range::db::NodeInfo_Edges* release_forward();
  inline void set_allocated_forward(::range::db::NodeInfo_Edges* forward);

  // required .range.db.NodeInfo.Edges reverse = 5;
  inline bool has_reverse() const;
  inline void clear_reverse();
  static const int kReverseFieldNumber = 5;
  inline const ::range::db::NodeInfo_Edges& reverse() const;
  inline ::range::db::NodeInfo_Edges* mutable_reverse();
  inline ::range::db::NodeInfo_Edges* release_reverse();
  inline void set_allocated_reverse(::range::db::NodeInfo_Edges* reverse);

  // required .range.db.NodeInfo.Tags tags = 6;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 6;
  inline const ::range::db::NodeInfo_Tags& tags() const;
  inline ::range::db::NodeInfo_Tags* mutable_tags();
  inline ::range::db::NodeInfo_Tags* release_tags();
  inline void set_allocated_tags(::range::db::NodeInfo_Tags* tags);

  // repeated uint64 graph_versions = 7;
  inline int graph_versions_size() const;
  inline void clear_graph_versions();
  static const int kGraphVersionsFieldNumber = 7;
  inline ::google::protobuf::uint64 graph_versions(int index) const;
  inline void set_graph_versions(int index, ::google::protobuf::uint64 value);
  inline void add_graph_versions(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      graph_versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_graph_versions();

  // @@protoc_insertion_point(class_scope:range.db.NodeInfo)
 private:
  inline void set_has_list_version();
  inline void clear_has_list_version();
  inline void set_has_crc32();
  inline void clear_has_crc32();
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_reverse();
  inline void clear_has_reverse();
  inline void set_has_tags();
  inline void clear_has_tags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 list_version_;
  ::google::protobuf::uint32 crc32_;
  ::google::protobuf::uint32 node_type_;
  ::range::db::NodeInfo_Edges* forward_;
  ::range::db::NodeInfo_Edges* reverse_;
  ::range::db::NodeInfo_Tags* tags_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > graph_versions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_nodeinfo_2eproto();
  friend void protobuf_AssignDesc_nodeinfo_2eproto();
  friend void protobuf_ShutdownFile_nodeinfo_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// NodeInfo_Adjacency

// required string id = 1;
inline bool NodeInfo_Adjacency::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo_Adjacency::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo_Adjacency::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo_Adjacency::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NodeInfo_Adjacency::id() const {
  return *id_;
}
inline void NodeInfo_Adjacency::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NodeInfo_Adjacency::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NodeInfo_Adjacency::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeInfo_Adjacency::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* NodeInfo_Adjacency::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeInfo_Adjacency::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint64 versions = 2;
inline int NodeInfo_Adjacency::versions_size() const {
  return versions_.size();
}
inline void NodeInfo_Adjacency::clear_versions() {
  versions_.Clear();
}
inline ::google::protobuf::uint64 NodeInfo_Adjacency::versions(int index) const {
  return versions_.Get(index);
}
inline void NodeInfo_Adjacency::set_versions(int index, ::google::protobuf::uint64 value) {
  versions_.Set(index, value);
}
inline void NodeInfo_Adjacency::add_versions(::google::protobuf::uint64 value) {
  versions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
NodeInfo_Adjacency::versions() const {
  return versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
NodeInfo_Adjacency::mutable_versions() {
  return &versions_;
}

// -------------------------------------------------------------------

// NodeInfo_Edges

// repeated .range.db.NodeInfo.Adjacency edges = 1;
inline int NodeInfo_Edges::edges_size() const {
  return edges_.size();
}
inline void NodeInfo_Edges::clear_edges() {
  edges_.Clear();
}
inline const ::range::db::NodeInfo_Adjacency& NodeInfo_Edges::edges(int index) const {
  return edges_.Get(index);
}
inline ::range::db::NodeInfo_Adjacency* NodeInfo_Edges::mutable_edges(int index) {
  return edges_.Mutable(index);
}
inline ::range::db::NodeInfo_Adjacency* NodeInfo_Edges::add_edges() {
  return edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Adjacency >&
NodeInfo_Edges::edges() const {
  return edges_;
}
inline ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Adjacency >*
NodeInfo_Edges::mutable_edges() {
  return &edges_;
}

// -------------------------------------------------------------------

// NodeInfo_Tags_KeyValue_Values

// required string data = 1;
inline bool NodeInfo_Tags_KeyValue_Values::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo_Tags_KeyValue_Values::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo_Tags_KeyValue_Values::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo_Tags_KeyValue_Values::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& NodeInfo_Tags_KeyValue_Values::data() const {
  return *data_;
}
inline void NodeInfo_Tags_KeyValue_Values::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void NodeInfo_Tags_KeyValue_Values::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void NodeInfo_Tags_KeyValue_Values::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeInfo_Tags_KeyValue_Values::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* NodeInfo_Tags_KeyValue_Values::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeInfo_Tags_KeyValue_Values::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint64 versions = 2;
inline int NodeInfo_Tags_KeyValue_Values::versions_size() const {
  return versions_.size();
}
inline void NodeInfo_Tags_KeyValue_Values::clear_versions() {
  versions_.Clear();
}
inline ::google::protobuf::uint64 NodeInfo_Tags_KeyValue_Values::versions(int index) const {
  return versions_.Get(index);
}
inline void NodeInfo_Tags_KeyValue_Values::set_versions(int index, ::google::protobuf::uint64 value) {
  versions_.Set(index, value);
}
inline void NodeInfo_Tags_KeyValue_Values::add_versions(::google::protobuf::uint64 value) {
  versions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
NodeInfo_Tags_KeyValue_Values::versions() const {
  return versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
NodeInfo_Tags_KeyValue_Values::mutable_versions() {
  return &versions_;
}

// -------------------------------------------------------------------

// NodeInfo_Tags_KeyValue

// required string key = 1;
inline bool NodeInfo_Tags_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo_Tags_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo_Tags_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo_Tags_KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& NodeInfo_Tags_KeyValue::key() const {
  return *key_;
}
inline void NodeInfo_Tags_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void NodeInfo_Tags_KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void NodeInfo_Tags_KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeInfo_Tags_KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* NodeInfo_Tags_KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeInfo_Tags_KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 key_version = 4;
inline bool NodeInfo_Tags_KeyValue::has_key_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInfo_Tags_KeyValue::set_has_key_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInfo_Tags_KeyValue::clear_has_key_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInfo_Tags_KeyValue::clear_key_version() {
  key_version_ = GOOGLE_ULONGLONG(0);
  clear_has_key_version();
}
inline ::google::protobuf::uint64 NodeInfo_Tags_KeyValue::key_version() const {
  return key_version_;
}
inline void NodeInfo_Tags_KeyValue::set_key_version(::google::protobuf::uint64 value) {
  set_has_key_version();
  key_version_ = value;
}

// repeated .range.db.NodeInfo.Tags.KeyValue.Values values = 2;
inline int NodeInfo_Tags_KeyValue::values_size() const {
  return values_.size();
}
inline void NodeInfo_Tags_KeyValue::clear_values() {
  values_.Clear();
}
inline const ::range::db::NodeInfo_Tags_KeyValue_Values& NodeInfo_Tags_KeyValue::values(int index) const {
  return values_.Get(index);
}
inline ::range::db::NodeInfo_Tags_KeyValue_Values* NodeInfo_Tags_KeyValue::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::range::db::NodeInfo_Tags_KeyValue_Values* NodeInfo_Tags_KeyValue::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue_Values >&
NodeInfo_Tags_KeyValue::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue_Values >*
NodeInfo_Tags_KeyValue::mutable_values() {
  return &values_;
}

// repeated uint64 versions = 3;
inline int NodeInfo_Tags_KeyValue::versions_size() const {
  return versions_.size();
}
inline void NodeInfo_Tags_KeyValue::clear_versions() {
  versions_.Clear();
}
inline ::google::protobuf::uint64 NodeInfo_Tags_KeyValue::versions(int index) const {
  return versions_.Get(index);
}
inline void NodeInfo_Tags_KeyValue::set_versions(int index, ::google::protobuf::uint64 value) {
  versions_.Set(index, value);
}
inline void NodeInfo_Tags_KeyValue::add_versions(::google::protobuf::uint64 value) {
  versions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
NodeInfo_Tags_KeyValue::versions() const {
  return versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
NodeInfo_Tags_KeyValue::mutable_versions() {
  return &versions_;
}

// -------------------------------------------------------------------

// NodeInfo_Tags

// repeated .range.db.NodeInfo.Tags.KeyValue keys = 1;
inline int NodeInfo_Tags::keys_size() const {
  return keys_.size();
}
inline void NodeInfo_Tags::clear_keys() {
  keys_.Clear();
}
inline const ::range::db::NodeInfo_Tags_KeyValue& NodeInfo_Tags::keys(int index) const {
  return keys_.Get(index);
}
inline ::range::db::NodeInfo_Tags_KeyValue* NodeInfo_Tags::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::range::db::NodeInfo_Tags_KeyValue* NodeInfo_Tags::add_keys() {
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue >&
NodeInfo_Tags::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::range::db::NodeInfo_Tags_KeyValue >*
NodeInfo_Tags::mutable_keys() {
  return &keys_;
}

// -------------------------------------------------------------------

// NodeInfo

// required uint64 list_version = 1;
inline bool NodeInfo::has_list_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo::set_has_list_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo::clear_has_list_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo::clear_list_version() {
  list_version_ = GOOGLE_ULONGLONG(0);
  clear_has_list_version();
}
inline ::google::protobuf::uint64 NodeInfo::list_version() const {
  return list_version_;
}
inline void NodeInfo::set_list_version(::google::protobuf::uint64 value) {
  set_has_list_version();
  list_version_ = value;
}

// required uint32 crc32 = 2;
inline bool NodeInfo::has_crc32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInfo::set_has_crc32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInfo::clear_has_crc32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInfo::clear_crc32() {
  crc32_ = 0u;
  clear_has_crc32();
}
inline ::google::protobuf::uint32 NodeInfo::crc32() const {
  return crc32_;
}
inline void NodeInfo::set_crc32(::google::protobuf::uint32 value) {
  set_has_crc32();
  crc32_ = value;
}

// required uint32 node_type = 3;
inline bool NodeInfo::has_node_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeInfo::set_has_node_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeInfo::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeInfo::clear_node_type() {
  node_type_ = 0u;
  clear_has_node_type();
}
inline ::google::protobuf::uint32 NodeInfo::node_type() const {
  return node_type_;
}
inline void NodeInfo::set_node_type(::google::protobuf::uint32 value) {
  set_has_node_type();
  node_type_ = value;
}

// required .range.db.NodeInfo.Edges forward = 4;
inline bool NodeInfo::has_forward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeInfo::set_has_forward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeInfo::clear_has_forward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeInfo::clear_forward() {
  if (forward_ != NULL) forward_->::range::db::NodeInfo_Edges::Clear();
  clear_has_forward();
}
inline const ::range::db::NodeInfo_Edges& NodeInfo::forward() const {
  return forward_ != NULL ? *forward_ : *default_instance_->forward_;
}
inline ::range::db::NodeInfo_Edges* NodeInfo::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) forward_ = new ::range::db::NodeInfo_Edges;
  return forward_;
}
inline ::range::db::NodeInfo_Edges* NodeInfo::release_forward() {
  clear_has_forward();
  ::range::db::NodeInfo_Edges* temp = forward_;
  forward_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_forward(::range::db::NodeInfo_Edges* forward) {
  delete forward_;
  forward_ = forward;
  if (forward) {
    set_has_forward();
  } else {
    clear_has_forward();
  }
}

// required .range.db.NodeInfo.Edges reverse = 5;
inline bool NodeInfo::has_reverse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeInfo::set_has_reverse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeInfo::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeInfo::clear_reverse() {
  if (reverse_ != NULL) reverse_->::range::db::NodeInfo_Edges::Clear();
  clear_has_reverse();
}
inline const ::range::db::NodeInfo_Edges& NodeInfo::reverse() const {
  return reverse_ != NULL ? *reverse_ : *default_instance_->reverse_;
}
inline ::range::db::NodeInfo_Edges* NodeInfo::mutable_reverse() {
  set_has_reverse();
  if (reverse_ == NULL) reverse_ = new ::range::db::NodeInfo_Edges;
  return reverse_;
}
inline ::range::db::NodeInfo_Edges* NodeInfo::release_reverse() {
  clear_has_reverse();
  ::range::db::NodeInfo_Edges* temp = reverse_;
  reverse_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_reverse(::range::db::NodeInfo_Edges* reverse) {
  delete reverse_;
  reverse_ = reverse;
  if (reverse) {
    set_has_reverse();
  } else {
    clear_has_reverse();
  }
}

// required .range.db.NodeInfo.Tags tags = 6;
inline bool NodeInfo::has_tags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeInfo::set_has_tags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeInfo::clear_has_tags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeInfo::clear_tags() {
  if (tags_ != NULL) tags_->::range::db::NodeInfo_Tags::Clear();
  clear_has_tags();
}
inline const ::range::db::NodeInfo_Tags& NodeInfo::tags() const {
  return tags_ != NULL ? *tags_ : *default_instance_->tags_;
}
inline ::range::db::NodeInfo_Tags* NodeInfo::mutable_tags() {
  set_has_tags();
  if (tags_ == NULL) tags_ = new ::range::db::NodeInfo_Tags;
  return tags_;
}
inline ::range::db::NodeInfo_Tags* NodeInfo::release_tags() {
  clear_has_tags();
  ::range::db::NodeInfo_Tags* temp = tags_;
  tags_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_tags(::range::db::NodeInfo_Tags* tags) {
  delete tags_;
  tags_ = tags;
  if (tags) {
    set_has_tags();
  } else {
    clear_has_tags();
  }
}

// repeated uint64 graph_versions = 7;
inline int NodeInfo::graph_versions_size() const {
  return graph_versions_.size();
}
inline void NodeInfo::clear_graph_versions() {
  graph_versions_.Clear();
}
inline ::google::protobuf::uint64 NodeInfo::graph_versions(int index) const {
  return graph_versions_.Get(index);
}
inline void NodeInfo::set_graph_versions(int index, ::google::protobuf::uint64 value) {
  graph_versions_.Set(index, value);
}
inline void NodeInfo::add_graph_versions(::google::protobuf::uint64 value) {
  graph_versions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
NodeInfo::graph_versions() const {
  return graph_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
NodeInfo::mutable_graph_versions() {
  return &graph_versions_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace db
}  // namespace range

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nodeinfo_2eproto__INCLUDED
